<?php

/**
 * Core functions for the Display Suite module.
 */

/**
 * Constants for settings status.
 */
define('DS_SETTINGS_UI', 1);
define('DS_SETTINGS_DEFAULT', 2);
define('DS_SETTINGS_OVERRIDDEN', 3);

/**
 * Constants for field types.
 */
define('DS_FIELD_TYPE_NON_DS', 'non_ds');
define('DS_FIELD_TYPE_THEME', 'theme');
define('DS_FIELD_TYPE_FUNCTION', 'function');
define('DS_FIELD_TYPE_PREPROCESS', 'preprocess');
define('DS_FIELD_TYPE_IGNORE', 'ignore');
define('DS_FIELD_TYPE_CODE', 'code');
define('DS_FIELD_TYPE_BLOCK', 'block');
define('DS_FIELD_TYPE_GROUP', 'group');
define('DS_FIELD_TYPE_MULTIGROUP', 'multigroup');

/**
 * Constants for field statuses.
 */
define('DS_FIELD_STATUS_STATIC', 1);
define('DS_FIELD_STATUS_DEFAULT', 2);
define('DS_FIELD_STATUS_CUSTOM', 3);
define('DS_FIELD_STATUS_OVERRIDDEN', 4);

/**
 * Constants for block fields rendering.
 */
define('DS_BLOCK_TEMPLATE', 1);
define('DS_BLOCK_TITLE_CONTENT', 2);
define('DS_BLOCK_CONTENT', 3);

/**
 * Constants for content field default values
 */
define('DS_DEFAULT_REGION', 'disabled');
define('DS_DISABLED_REGION', 'disabled');
define('DS_DEFAULT_LAYOUT', 'default');
define('DS_DEFAULT_FORMAT', 'default');
define('DS_DEFAULT_LABEL_FORMAT', 'hidden');
define('DS_DEFAULT_WEIGHT', -19);

/**
 * Constants for theme callback defaults
 */
define('DS_DEFAULT_THEME_REGIONS', 'ds_regions');
define('DS_DEFAULT_THEME_REGION', 'ds_region');
define('DS_DEFAULT_THEME_FIELD', 'ds_field');
define('DS_DEFAULT_THEME_FIELDSET', 'ds_group_fieldset_open');

/**
 * Constants for menu paths
 */
define('DS_PATH_BASE', 'admin/build/ds');
define('DS_PATH_LAYOUT', 'admin/build/ds/layout');
define('DS_PATH_TOOLS', 'admin/build/ds/tools');
define('DS_PATH_STYLES', 'admin/build/ds/styles');
define('DS_PATH_MODULES', 'admin/build/ds/modules');

/**
 * Implementation of hook_theme().
 */
function ds_theme() {
  require_once('includes/ds.registry.inc');
  return _ds_theme();
}

/**
 * Implementation of hook_views_api().
 */
function ds_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'ds') .'/views',
  );
}

/**
 * Implementation of hook_ds_plugins().
 */
function ds_ds_plugins() {
  require_once('includes/ds.registry.inc');
  return _ds_plugins();
}

/**
 * Implementation of hook_ds_layouts()
 */
function ds_ds_layouts() {
  require_once('includes/ds.registry.inc');
  return _ds_ds_layouts();
}

/**
 * Implementation of hook_features_api().
 */
function ds_features_api() {
  require_once('includes/ds.features.inc');
  return _ds_features_api();
}

/**
 * Tell ctools where we keep default plugins
 */
function ds_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ds' && !empty($plugin)) {
    return "plugins/$plugin";
  }
}

/**
 * Fetch metadata on a specific ds_field plugin.
 *
 * @param $field_type
 *   Name of a ds_field type.
 *
 * @return
 *   An array with information about the requested field type.
 */
function ds_get_field_type($field_type) {
  ctools_include('plugins');
  return ctools_get_plugins('ds', 'ds_field', $field_type);
}

/**
 * Fetch metadata for all ds_field plugins.
 *
 * @return
 *   An array of arrays with information about all available field types.
 */
function ds_get_field_types() {
  static $types = NULL;

  if (!isset($types)) {
    ctools_include('plugins');
    $types = ctools_get_plugins('ds', 'ds_field');
  }

  return $types;
}

/**
 * Implementation of hook_flush_caches().
 */
function ds_flush_caches() {
  // Reset fields cache.
  ds_reset_fields_cache();

  // Import default settings.
  ds_import_default_data();
  return array();
}

/**
 * Implementation of hook_block().
 */
function ds_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      require_once('includes/ds.registry.inc');
      return _ds_block_list();
      break;
    case 'view':
      $content = array();
      $ds_blocks = variable_get('ds_blocks', array());
      if (isset($ds_blocks[$delta])) {
        $info = $ds_blocks[$delta];
        $data = $info['data'];
        if (isset($data['filename']) && isset($data['class'])) {
          require_once($data['filename']);
          $class = $data['class'];
          $plugin = new $class();
          if (method_exists($plugin, 'block_view')) {
            $content = $plugin->block_view($info);
          }
        }
      }
      return $content;
      break;
  }
}

/**
 * Set or get static variables at runtime
 *
 * If passed a key and data, will set the data. If passed only a key, will
 * attempt to retrieve the data and return it.
 *
 * @param $key
 *  The key to use for the variable
 * @param $data
 *  The data to set
 *
 * @return
 *  If the key is found, the data, or FALSE. If data is provided, TRUE if the 
 * data is set successfully.
 */
function ds_static_variables($key, $data = NULL) {
  static $variables = array();
  if (!isset($data) && isset($key) && isset($variables[$key])) {
    return $variables[$key];
  }
  elseif (!isset($variables[$key]) && isset($data)) {
    $variables[$key] = array();
    $variables[$key][] = $data;
    return TRUE;
  }
  elseif (isset($variables[$key]) && isset($data)) {
    $variables[$key][] = $data;
    return TRUE;
  }
  return FALSE;
}

/**
 * Return API information about a module and type
 *
 * @param string $module 
 *  The module to get the API information from
 * @param string $type_name 
 *  The object type name
 */
function ds_api_info($module, $type_name = 'all') {
  static $api_info = array();

  if (!isset($api_info[$module][$type_name])) {

    // Gather information.
    $function = $module .'_ds_api';
    if (function_exists($function)) {
      $api_data = call_user_func($function);
    }
    else {
      return FALSE;
    }

    $api_info[$module][$type_name] = $api_data;
    if (!isset($api_info[$module][$type_name]['extra'])) {
      $api_info[$module][$type_name]['extra'] = array();
    }

    // Extra info needed or not.
    if ($type_name != 'all' && !empty($api_data['extra'])) {
      $extra = array();
      $types = $api_data['types']();
      $type_info = $types[$type_name];
      foreach ($api_data['extra'] as $key) {
        $extra[$key] = $type_info->{$key};
      }
      $api_info[$module][$type_name]['extra'] = $extra;
    }
  }

  return $api_info[$module][$type_name];
}

/**
 * Function to reset fields cache.
 */
function ds_reset_fields_cache() {
  db_query("UPDATE {ds_settings} set fields = ''");
}

/**
/**
 * Format content for use in an item
 */
function ds_field_format_content($field) {
  $content = NULL;

  if (isset($field['formatter']) || isset($field['function'])) {
    // Load includes
    if (isset($field['file'])) {
      include_once($field['file']);
    }
    // If its a function, call it
    if (isset($field['function']) && !empty($field['function'])) {
      if (function_exists($field['function'])) {
        $content = call_user_func($field['function'], $field);
      }
    }
    // Otherwise, pipe through theme()
    else {
      $content = theme($field['formatter'], $field);
    }
  }

  return $content;
}

/**
 * Return a value for a field or group
 *
 * @param array $item
 *  The item to render. The item requires a 'content' key.
 *
 * @return
 *  A rendered item, or FALSE if no content was found
 */
function ds_render_item($item){
  $content = FALSE;

  // Tabs must use the ds_tabs themeing fuction
  if (isset($item['tab'])) {
    $item['theme'] = 'ds_tabs';
  }
  // If no theme function is set, use the default
  elseif (empty($item['theme'])) {
    $item['theme'] = DS_DEFAULT_THEME_FIELD;
  }

  $content = theme($item['theme'], $item);

  // theme() can return anything, but we only want to return content where
  // there is 1 or more characters
  if (isset($content) && strlen($content) > 0) {
    return $content;
  }

  return FALSE;
}

/**
 * Return a rendered fieldset group
 *
 * @param stdClass $object
 *  the object (e.g. a node) containing the group to be rendered
 * @param string $group_key
 *  the key of the group to render
 * @param array $vars (optional)
 *  the $vars array
 * 
 * @return 
 *  a string containing the fully-rendered group, or FALSE if one is not 
 *  rendered
 */
function ds_render_group(&$object, $group_key, $vars = array()){
  $object->ds_fields[$group_key]['content'] = '';

  if (array_key_exists($group_key, $object->ds_fields)) {

    // Sort group items by weight, and pass them to the render function
    asort($object->ds_groups[$group_key]);
    foreach ($object->ds_groups[$group_key] as $field_key => $field_weight) {
      // Items inside groups wont have a content value set, so assign it now
      // @todo find a way to move ds_set_content into a consistent place for 
      // all fields, e.g. ds_build_fields_and_objects
      $object->ds_fields[$group_key]['fields'][$field_key]['content'] = ds_get_content($object->ds_fields[$group_key]['fields'][$field_key], $vars, $field_key);
      $object->ds_fields[$group_key]['fields'][$field_key]['rendered'] = ds_render_item($object->ds_fields[$group_key]['fields'][$field_key]);

      $object->ds_fields[$group_key]['content'] .= $object->ds_fields[$group_key]['fields'][$field_key]['rendered'];
    }

    $object->ds_fields[$group_key]['count'] = count($object->ds_fields[$group_key]['fields']); // @todo - is this still required?

    // Render the complete group
    if (!empty($object->ds_fields[$group_key]['content'])) {
      $object->ds_fields[$group_key]['rendered'] = ds_render_item($object->ds_fields[$group_key]);
    }
  }

  return $object->ds_fields[$group_key]['rendered'];
}

/**
 * Return a rendered multigroup group
 *
 * Multigroups are not fieldsets but multi-value compound fields. The
 * individual field values must be rebuilt across fields to produce the 
 * correct structure..
 *
 * @param stdClass $object
 *  the object (e.g. a node) containing the group to be rendered
 * @param string $group_key
 *  the key of the group to render
 * @param array $vars (optional)
 *  the $vars array
 *
 * @return 
 *  a string containing the fully-rendered group, or FALSE if one is not 
 *  rendered
 */
function ds_render_multigroup(&$object, $group_key, $vars = array()){
  // Add CSS for multigroups
  // It would be nice to avoid this, however when returning individual CCK
  // rendered rows from a multigroup, every label after the first is hidden.
  drupal_add_css(drupal_get_path('module', 'ds') .'/css/ds-multigroup.css');

  // Initialise storage for fieldset subgroups
  $object->ds_fields[$group_key]['subgroups'] = array();

  // Iterate over the number of properties ($fields) in the multigroup, and
  // construct a single numerically keyed, compound value array representing
  // the field. This is complicated because we are building individually 
  // rendered fields for fieldset implementations, as well as array keys for 
  // things like tables.
  $field_keys = array_keys($object->ds_fields[$group_key]['fields']);
  $subgroup_count = count($vars[$field_keys[0]]);

  for ($i = 0; $i < $subgroup_count; $i++) {
    $object->ds_fields[$group_key]['subgroups']['rows'][$i] = array(
      'index' => $group_key . '_delta_' . $i,
      'class' => 'content-multigroup-wrapper field-multigroup-row ds-multigroup-'. $group_key .'-delta-'. $i . ($i % 2 ? ' odd' : ' even'),
      'weight' => $i - 100,
    );

    // Iterate over fields in the group and move their values into subgroups
    foreach ($object->ds_fields[$group_key]['fields'] as $field_key => $field_weight) {
      $object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key] = $object->ds_fields[$group_key]['fields'][$field_key];
      $object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key]['view'] = ds_get_content($object->ds_fields[$group_key]['fields'][$field_key], $vars[$field_key][$i], 'view');
      
      // The field title may not be stored on the field, so retrieve it from
      // CCK via nd_cck
      if (empty($object->ds_fields[$group_key]['fields'][$field_key]['title'])) {
        $cck_field = content_fields($field_key, $object->type);
        $object->ds_fields[$group_key]['fields'][$field_key]['title'] = nd_cck_get_label_value($cck_field, $object->build_mode);
      }
      $object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key]['title'] = $object->ds_fields[$group_key]['fields'][$field_key]['title'];
      
      // CCK returns different content depending on its default display
      // settings, so we fallback on the default rendered view and pass it
      // through the ds rendering pipeline
      $object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key]['content'] = $object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key]['view'];
      $object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key]['type'] = 'ds';
      // Because CCK fields normally ignore ds formatters, we need to explicitly
      // set the pipeline for multigroups to use DS, or they dont get formatted
      $object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key]['rendered'] = ds_render_item($object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key]);

      // Add subgroup row information
      $object->ds_fields[$group_key]['subgroups']['rows'][$i]['title'] = $object->content[$group_key]['group'][$i]['#title'];

      // Add the rendered value to its parent subgroup content
      $object->ds_fields[$group_key]['subgroups']['rows'][$i]['content'] .= $object->ds_fields[$group_key]['subgroups']['rows'][$i]['fields'][$field_key]['rendered'];
    }

    // Build the rendered subgroup row for use in fieldsets etc.
    $object->ds_fields[$group_key]['subgroups']['rows'][$i]['rendered'] = ds_render_item($object->ds_fields[$group_key]['subgroups']['rows'][$i]);
  }

  // Add fields for reference
  $object->ds_fields[$group_key]['subgroups']['fields'] = $object->ds_fields[$group_key]['fields'];

  // Subgroups may be rendered as if they are a single field, so we must construct
  // a wrapping field object to pass to ds_render_item()
  $object->ds_fields[$group_key]['subgroups']['key'] = $group_key .'_subgroup';
  $object->ds_fields[$group_key]['subgroups']['theme'] = isset($object->ds_fields[$group_key]['subgroup_theme']) ? $object->ds_fields[$group_key]['subgroup_theme'] : 'ds_multigroup_fieldset';
  // To be passed to a rendering function, the 'content' key must exist,
  // however the subgroup has not rendered content at this point
  $object->ds_fields[$group_key]['subgroups']['content'] = TRUE;

  // Render the subgroups
  $object->ds_fields[$group_key]['content'] = ds_render_item($object->ds_fields[$group_key]['subgroups']);

  // Render the group wrapper
  $object->ds_fields[$group_key]['rendered'] = ds_render_item($object->ds_fields[$group_key]);

  return $object->ds_fields[$group_key]['rendered'];
}

/**
 * Helper function to get content for a field
 *
 * @param stdClass $item
 *  the item to set content for
 * @param array $content_vars (optional)
 *  the $vars array, or an array containing possible values
 * @param string $vars_key 
 *  the key within $content_vars to retrieve
 *
 * @return 
 *  the content value as a string, or FALSE if none was found
 */
function ds_get_content($item, $content_vars = array(), $vars_key = NULL) {
  if (!is_array($item)){
    return FALSE;
  }

  $content = '';
  // If content has been prerendered by ds_build_fields_and_objects use that
  if (!empty($item['content'])) {
    $content = $item['content'];
  }
  // If content has been rendered by another source (i.e. CCK) use that
  elseif (!empty($content_vars)) {
    // CCK fields will use $vars_key.'_rendered'
    // @todo: this is a bit of a hacky way to get CCK content, refactor
    if (isset($content_vars[$vars_key .'_rendered'])) {
      $content = $content_vars[$vars_key .'_rendered'];
    }
    elseif (isset($content_vars[$vars_key])) {
      $content = $content_vars[$vars_key];
    }
  }

  if (!empty($content)){
    return $content;
  }

  return FALSE;
}

/**
 * Factory function to initalise a new dsDisplay object
 *
 * @return
 *  A correctly initialised display object
 */
function ds_create_display(){
  module_load_include('php', 'ds', 'includes/dsDisplay');
  return new dsDisplay();
}

/**
 * Factory function to initalise a new Field object
 *
 * @return
 *  A correctly initialised Field object
 */
function ds_create_field($type){
  module_load_include('php', 'ds', 'includes/dsField');
  $type_info = ds_get_field_type($field_type);
  $field = new $type_info['class'];
  return $field;
}

/**
 * Load a layout
 */
function ds_get_layout($name = DS_DEFAULT_LAYOUT) {
  $layouts = module_invoke_all('ds_layouts');
  foreach ($layouts as $key => $layout) {
    if ($key == $name) {
      // Every layout has a disabled region
      $layout['regions']['disabled'] = array(
        'name' => t('Disabled'),
      );
      return $layout;
    }
  }
}

/**
 * Load regions for a layout
 */
function ds_get_regions($layout_name) {
  $layout = ds_get_layout($layout_name);
  return $layout['regions'];
}

/**
 * Generalised API function to invoke HOOK_dsapi in other modules.
 *
 * @param string $op
 *  The operation
 * @param array $args
 *  (optional) An array of variables to pass to the hook
 *
 * @return
 *  The results of the given operation
 */
function ds_api_invoke($callback, $args = array()) {
  foreach (module_implements('dsapi') as $module) {
    return module_invoke($module, 'dsapi', $args);
  }
}

/**
 * Get settings
 *
 * @param string $module The name of the module
 * @param string $type The name of the type
 * @param string $build_mode The name of the build mode
 * @param string $return The name of the record to return
 * @param string $reset Whether to reset the static cache or not.
 */
function ds_get_settings($module, $type, $build_mode, $return = 'settings', $reset = FALSE) {
  static $settings = array();

  if ($reset) {
    $settings = array();
  }

  if (!isset($settings[$module][$type][$build_mode])) {
    $settings[$module][$type][$build_mode] = array();
    $record = db_fetch_array(db_query("SELECT module, type, build_mode, settings, fields FROM {ds_settings} WHERE module = '%s' AND type = '%s' AND build_mode = '%s'", $module, $type, $build_mode));
    if (isset($record['module'])) {
      $settings[$module][$type][$build_mode]['settings'] = unserialize($record['settings']);
      $settings[$module][$type][$build_mode]['fields'] = unserialize($record['fields']);
    }
  }

  // Ensure that settings always returns a layout value, even one none is set
  if (!isset($settings[$module][$build_mode]['settings']['layout'])) {
    $settings[$module][$build_mode]['settings']['layout'] = DS_DEFAULT_LAYOUT;
  }

  return isset($settings[$module][$type][$build_mode][$return]) ? $settings[$module][$type][$build_mode][$return] : array();
}

/**
 * Return a value or return the default if empty.
 *
 * @param array $settings The settings loaded for a type.
 * @param string $type The name of the type to search (ie fields, regions)
 * @param string $key The name of the key to search in $type.
 * @param string $search_key The name of the key to search in $key.
 * @param string $default The default value.
 * @param mixed default value.
 */
function ds_default_value($settings, $type, $key = NULL, $search_key = NULL, $default = NULL) {
  if ($key == NULL) {
    return (isset($settings[$type])) ? $settings[$type] : NULL;
  }

  return (isset($settings[$type][$key][$search_key])) ? $settings[$type][$key][$search_key] : $default;
}

/**
 * API function to get fields.
 *
 * @param string $module The name of the module.
 * @param string $type_name The name of object (ie, page or story for node types, profile for users)
 * @param string $build_mode The build mode.
 * @param array $extra Extra properties we might want to check on (ie has_body property).
 * @param boolean $reset Whether we need to reset the fields cache or not.
 * @param boolean $cache Whether we need to cache the fields or not.
 * @return array of fields.
 */
function ds_get_fields($module, $type_name, $build_mode, $extra = array(), $reset = FALSE, $cache = TRUE) {
  static $static_fields = array();

  if (!isset($static_fields[$module][$type_name][$build_mode])) {

    // Do we have them cached or not ?
    $settings = ds_get_settings($module, $type_name, $build_mode, 'fields');
    if ((!isset($settings) || empty($settings)) || $reset) {

      // Fields in code.
      $fields = array();
      foreach (module_implements('ds_fields') as $prefix) {
        $function = $prefix .'_ds_fields';
        if (function_exists($function)) {
          $all_fields = $function($type_name, $build_mode, $extra);
          if (!empty($all_fields)) {
            foreach ($all_fields as $key => $field_results) {
              if ($key === $module) {
                $fields = array_merge($field_results, $fields);
                foreach ($fields as $key => $field) {
                  $exclude = (isset($field['exclude'][$type_name]) && $field['exclude'][$type_name] === $type_name) ? TRUE : FALSE;
                  if ($exclude) {
                    unset($fields[$key]);
                  }
                }
              }
            }
          }
        }
      }

      // Fields via the UI.
      $db_fields = variable_get($module .'_fields', array());
      if (!empty($db_fields)) {
        foreach ($db_fields as $key => $field) {
          $fields[$key] = array(
            'title' => check_plain($field['title']),
            'type' => $field['type'],
            'status' => $field['status'],
            'properties' => $field['properties'],
          );
          $exclude = (isset($field['exclude'][$type_name]) && $field['exclude'][$type_name] === $type_name) ? TRUE : FALSE;
          if ($exclude) {
            unset($fields[$key]);
          }
        }
      }

      // Do not save the CCK fields.
      if ($cache) {
        foreach ($fields as $field_key => $field_value) {
          if (isset($field_value['storage'])) {
            unset($fields[$field_key]);
          }
        }
      }

      // Give modules a change to alter the fields.
      drupal_alter('ds_fields', $fields);

      // Do we cache or not ?
      if ($cache) {
        db_query("UPDATE {ds_settings} set fields = '%s' WHERE module = '%s' AND type = '%s' AND build_mode = '%s'", serialize($fields), $module, $type_name, $build_mode);
      }
    }
    else {
      $fields = $settings;
    }

    // Store the fields.
    $static_fields[$module][$type_name][$build_mode] = $fields;
  }

  return $static_fields[$module][$type_name][$build_mode];
}

/**
 * Api function to return all build modes.
 *
 * @param string $module Return build modes for a module.
 * @param boolean $reset Whether to reset the build modes.
 * @return array Collection of build modes.
 */
function ds_get_build_modes($module = NULL, $reset = FALSE) {

  $build_modes = variable_get('ds_all_build_modes', array());

  if (empty($build_modes) || $reset) {
    require_once('includes/ds.registry.inc');
    $build_modes = _ds_register_build_modes();
  }

  if ($module != NULL) {
    return $build_modes[$module];
  }
  else {
    return $build_modes;
  }
}

/**
 * Process plugins.
 *
 * @param stdClass $display 
 *  The display built by ds_render_content
 * @param stdClass $object
 *  The original object being processed
 * @param array $vars
 *  The variables used to build that display
 */
function ds_plugins_process(&$display, $object, $vars) {
  $plugins = variable_get($display->api_info['module'] .'_plugin_settings', array());
  if (!empty($plugins)) {
    foreach ($plugins as $key => $data) {
      if (isset($data['filename']) && isset($data['class'])) {
        require_once($data['filename']);
        $class = $data['class'];
        $plugin = new $class();
        $plugin->execute($vars, $display, $display->display_settings, $object->type, $display->api_info['module']);
      }
    }
  }
}

/**
 * Wrapper function around PHP eval(). We don't use drupal_eval
 * because custom fields might need properties from the current
 * object.
 *
 * @param string $code The code to evaluate from the custom field.
 * @param stdClass $object An object to use for evaluation.
 * @return string $output The output from eval.
 */
function ds_eval($code, $object) {
  global $theme_path, $theme_info, $conf;

  // Store current theme path.
  $old_theme_path = $theme_path;

  // Restore theme_path to the theme, as long as ds_eval() executes,
  // so code evaluted will not see the caller module as the current theme.
  // If theme info is not initialized get the path from theme_default.
  if (!isset($theme_info)) {
    $theme_path = drupal_get_path('theme', $conf['theme_default']);
  }
  else {
    $theme_path = dirname($theme_info->filename);
  }

  ob_start();
  print eval('?>'. $code);
  $output = ob_get_contents();
  ob_end_clean();

  // Recover original theme path.
  $theme_path = $old_theme_path;

  return $output;
}

/**
 * Return array of available regions.
 * @deprecated
 *
 * This is a multi dimensional array because when ordering fields on the
 * display, we want them to order in a logical order. However, when
 * rendering the HTML, we want left-right-middle for easy css practice.
 *
 * @param string $regions Whether to return all regions or not.
 * @return array $regions Collection of regions.
 */
function ds_regions($regions = 'all', $render = FALSE) {
  if ($regions == 'all') {
    if ($render == FALSE) {
      return array(
        'header' => t('Header'),
        'left' => t('Left'),
        'middle' => t('Middle'),
        'right' => t('Right'),
        'footer' => t('Footer'),
        'disabled' => t('Disabled')
      );
    }
    else {
      return array(
        'header' => t('Header'),
        'middle' => t('Middle'),
        'left' => t('Left'),
        'right' => t('Right'),
        'footer' => t('Footer'),
        'disabled' => t('Disabled'),
      );
    }
  }
  else {
    return array(
      'middle' => t('Enabled'),
      'disabled' => t('Disabled')
    );
  }
}

/**
 * Function to check if a field is set for a type and build mode.
 *
 * @param string $module The module to get the settings for.
 * @param string $type_name The name of the object type.
 * @param string $build_mode The key of the build mode.
 * @param string $field The name of the field to check for.
 */
function ds_show_field($module, $type_name, $build_mode, $field) {
  static $show_fields = array();
  if (!isset($show_fields[$module][$type_name][$build_mode][$field])) {
    $display_settings = ds_get_settings($module, $type_name, $build_mode);
    $show_fields[$module][$type_name][$build_mode][$field] = (isset($display_settings['fields'][$field]) && $display_settings['fields'][$field]['region'] != 'disabled') ? TRUE : FALSE;
  }
  return $show_fields[$module][$type_name][$build_mode][$field];
}

/**
 * Import default display data from modules.
 *
 * @param string $module The module to import.
 * @param string $type The object type to import.
 * @param string $build_mode The build mode to import.
 */
function ds_import_default_data($module = '', $type = '', $build_mode = '') {
  $data = module_invoke_all('ds_default_settings');
  if (!empty($data)) {
    module_load_include('inc', 'ds', 'includes/ds.tools');
    ds_import_data($data, FALSE, FALSE, $module, $type, $build_mode);
  }
}

/**
 * Return elements of an array which are children (i.e. not starting with #)
 * 
 * This is a direct port of element_children from Drupal 7
 *
 * @param $elements
 *  The element array whose children are to be identified.
 * @param $sort
 *  Boolean to indicate whether the children should be sorted by weight.
 *
 * @return
 *  The array keys of the element's children.
 */
function ds_element_children(&$elements, $sort = FALSE) {
  // Do not attempt to sort elements which have already been sorted.
  $sort = isset($elements['#sorted']) ? !$elements['#sorted'] : $sort;

  // Filter out properties from the element, leaving only children.
  $children = array();
  $sortable = FALSE;
  foreach ($elements as $key => $value) {
    if ($key === '' || $key[0] !== '#') {
      $children[$key] = $value;
      if (is_array($value) && isset($value['#weight'])) {
        $sortable = TRUE;
      }
    }
  }
  // Sort the children if necessary.
  if ($sort && $sortable) {
    uasort($children, 'element_sort');
    // Put the sorted children back into $elements in the correct order, to
    // preserve sorting if the same element is passed through
    // element_children() twice.
    foreach ($children as $key => $child) {
      unset($elements[$key]);
      $elements[$key] = $child;
    }
    $elements['#sorted'] = TRUE;
  }

  return array_keys($children);
}

/**
 * Given an array of attributes, convert it to a string suitable for use in
 * a theme function
 *
 * @param $attributes
 *  An array of attributes keyed by attributes name
 */
function ds_clean_attributes($attributes) {
  // Collect attribute information 
  foreach ($attributes as $key => $attr){
    if (is_array($attr)) {
      $attributes[$key] = implode(' ', $attributes[$key]);
    }
  }
  return ' '.drupal_attributes($attributes);
}

/**
 * Create a machine name from a set of parts
 *
 * @param $parts
 *  an array of name parts to use
 *
 * @return string
 *  a machine name, or FALSE if not enough information was provided
 */
function ds_machine_name($parts = array()) {

  $name = implode('_', $parts);

  return $name;
}